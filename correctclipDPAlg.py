from intervaltree import Interval, IntervalTree
import sys
import numpy as np


"""
A class representing a physical operator tree
"""
class PhysOpTree:
    """
    op_str: A string representing the operation to be performed
    res_int: the expected result interval
    children: a list of PhysOpTree objects containing the intervals to be
    operated on to get res_int
    """
    def __init__(self, op_str, res_int, children):
        self.op_str = op_str
        self.res_int = res_int
        self.children = children
        
    def printToString(self):
        prStr = "{" + self.op_str + "," + str(self.res_int) + " "
        for c in self.children:
            prStr += c.printToString()
        prStr += "}"
        return prStr
    

#compute cost of merging i1 with i2
def est_Single(i1, i2):
    base_ccost = 10
    merge_cost = 20
    if isIn(i1,i2): #if i1 is contained in i2
        print("Why are you comparing")
        print(i1)
        print("to")
        print(i2)
        return -1 #you should be cropping, not merging
    if isIn(i2,i1): #if i2 is contained in i1
        print("Why are you comparing")
        print(i1)
        print("to")
        print(i2)
        return -1 #you should be cropping, not merging
    if i1.begin - i2.end < 0 and i1.end - i2.end > 0:
        crop_cost = abs(i1.begin - i2.end) * base_ccost
    elif i2.begin - i1.end < 0 and i2.end - i1.end > 0:
        crop_cost = abs(i2.begin - i1.end) * base_ccost
    else:
        crop_cost = 0
    tot_cost = merge_cost + crop_cost
    return tot_cost

#compute cost of merging i2, which as already been materialized,
#with i1, which needs to be materialized
def est_Chain(i1, i2=None):
    base_ccost = 10
    #merge_cost = 20
    base_mcost = 10
    if i2 is None:
        return (i1[1] - i1[0])*base_mcost
    if isIn(i1,i2): #if i1 is contained in i2
        print("Why are you comparing")
        print(i1)
        print("to")
        print(i2)
        return -1 #you should be cropping, not merging
    if isIn(i2,i1): #if i2 is contained in i1
        print("Why are you comparing")
        print(i1)
        print("to")
        print(i2)
        return -1 #you should be cropping, not merging
    if i1[0] - i2[1] < 0 and i1[1] - i2[1] > 0:
        crop_cost = abs(i1[0] - i2[1]) * base_ccost
    elif i2[0] - i1[1] < 0 and i2[1] - i1[1] > 0:
        crop_cost = abs(i2[0] - i1[1]) * base_ccost
    else:
        crop_cost = 0
    #merge_cost = (i1[1] - i1[0] + i2[1] - i2[0])*base_mcost
    merge_cost = (i1[1] - i1[0])*base_mcost
    tot_cost = merge_cost + crop_cost
    return tot_cost

#check if i1 is contained in i2
def isIn(i1,i2):
    return i1.begin >= i2.begin and i1.end <= i2.end

#compute cost of cropping i1 into i2
def crop_Cost(i1,i2):
    if isIn(i2,i1):
        base_ccost = 10
        return (i2.begin - i1.begin + i1.end - i2.end)*base_ccost
    return -1

#insert the clips into an interval tree
#and then find all intervals overlapping with the given one
def clips_in_range(clips, i1):
    """
    clips: a list of pairs representing intervals
    Later on, we'll want to replace this with the actual header + clip file
    structure, and create the intervals first.
    """
    t = IntervalTree(Interval(begin, end, "%d-%d" % (begin, end)) for begin, end in clips)
    tset = t.overlap(i1[0],i1[1])
    tlst = sorted(list(tset), key=lambda x: x.begin, reverse=True)
    return tlst
    
def construct_Sol(clst, H, bg, targInt):
    target = (targInt.begin, targInt.end)
    if target in H:
        isM, ind = H[target]
        if not isM:
            """
            Base case: if the target interval is equal to the interval given by
            the index, then we're done
            """
            cInt = clst[ind]
            if cInt.begin == target[0] + bg and cInt.end == target[1] + bg:
                return PhysOpTree("retrieve", [cInt.begin, cInt.end], [])
            else:
                childlst = []
                newst = cInt.begin - bg
                newend = cInt.end - bg
                newInt = Interval(newst, newend, (newst,newend))
                childlst.append(construct_Sol(clst, H, bg, newInt))
                return PhysOpTree("crop", [bg + target[0], bg + target[1]], childlst)
        else:
            t1 = Interval(targInt.begin, ind, (targInt.begin, ind))
            t2 = Interval(ind, targInt.end, (ind, targInt.end))
            if t1.begin == target[0] and t1.end == target[1]:
                """
                there must be some mistake, because a length 2 interval cannot
                be constructed by merging any other intervals at all. The only way to
                construct such an interval is by cropping down an interval that
                contains it
                """
                raise Exception("ERROR: length-2 interval cannot be generated by merging: " + str(t1.begin) + "," + str(t1.end))
            childlst = []
            childlst.append(construct_Sol(clst,H,bg,t1))
            childlst.append(construct_Sol(clst,H,bg,t2))
            actualTInt = [targInt.begin + bg, targInt.end + bg]
            return PhysOpTree("merge", actualTInt, childlst)
    else:
        raise Exception("ERROR: all intervals should be present in hashmap: " + str(targInt.begin) + "," + str(targInt.end))
            

def dp_alg(clst, target):
    tlen = target[1] - target[0] + 1
    memo = np.full((tlen,tlen), sys.maxsize)
    H = {}
    targInt = Interval(target[0], target[1], target)
        
    for l in range(2,tlen+1): #l actually represents the length of the interval
        for i in range(tlen-l+1):
            j = i + l - 1
            st = targInt.begin + i
            end = targInt.begin + j
            #if the interval is already in the list, the cost is 0
            ints = [(n,x) for n,x in enumerate(clst) if x.begin == st and x.end == end]
            if ints:
                memo[i][j] = 0
                """
                Originally, I was thinking of making the cost of retrieving a
                clip already in the database 0, but you can think of this cost
                as the cost of converting a clip to a vstream object after first
                retrieving it
                """
                #memo[i][j] = est_Chain((st,end))
                H[(i,j)] = (False, ints[0][0])
                continue
            #compare the min cost of cropping, vs min cost of constructing
            #interval from clip--simple            
            ijInt = Interval(st, end, (st,end))
            memo[i][j] = sys.maxsize
            cov = [x for x in clst if isIn(ijInt,x)]
            if cov:
                if i == 0 and j == 1:
                    print(cov)
                min_ccost = sys.maxsize
                min_int = -1
                for m,c in enumerate(clst):
                    cost = crop_Cost(c, ijInt)
                    if cost != -1 and cost < min_ccost:
                        min_ccost = cost
                        min_int = m
                if i == 0 and j == 1:
                    print("Cost of 0,1: " + str(min_ccost))
                    print("index for 0,1: " + str(min_int))
                #This doesn't work, because we need the indices of the clst
#                cclst = list(map(lambda x,y: crop_Cost(x,y), cov, [ijInt]*len(cov)))
#                min_ccost = min(cclst)
#                min_int = cclst.index(min_ccost)
                memo[i][j] = min_ccost
                H[(i,j)] = (False,min_int) #note: this represents the index
                #to the clip to crop in the original list! NOT the breaking
                #point for an interval. We will need to account for the
                #difference in meaning when we go back and reconstruct the
                #result list
            for k in range(i,j-1):
                kpt = targInt.begin + k
                t1 = Interval(st,kpt+1,(st,kpt+1))
                t2 = Interval(kpt+1,end,(kpt+1,end))
                if memo[i][k+1] == sys.maxsize:
                    raise Exception("ERROR: Not supposed to use entry: " + str(i) + "," + str(k+1))
                if memo[k+1][j] == sys.maxsize:
                    raise Exception("ERROR: Not supposed to use entry: " + str(k+1) + "," + str(j))
                #q = memo[i][k+1] + memo[k+1][j] + est_Single(t1,t2)
                t1cost = memo[i][k+1]
                t2cost = memo[k+1][j]
                if t1cost == 0:
                    """
                    This will tell us that t1 can be directly retrieved from the
                    DB.
                    """
                    t1cost = est_Chain(t1)
                q = t1cost + t2cost + est_Chain(t2,t1)
                if q < memo[i][j]:
                    memo[i][j] = q
                    H[(i,j)] = (True, k+1) #this represents the optimal breaking
                    #point, not the position in the clip to be cropped.
    print(memo)
    print(H)
    reslst = construct_Sol(clst,H,targInt.begin, Interval(0, targInt.end - targInt.begin, (0, targInt.end - targInt.begin)))
    return (memo[0, target[1]-target[0]],reslst)

#ivs = [(1,3),(2,5),(3,4),(4,5)]
#ivs = [(0,3),(3,8),(8,11),(11,15),(15,18),(18,20),(2,5),(5,7),(7,17),(14,17),(17,20)]
ivs = [(0,3),(3,7),(7,11),(11,15),(15,18),(18,20),(0,5),(5,7),(7,10),(10,14),(14,17),(17,20)]
#i1 = [1,5]
i1 = [3,17]
ivsObjs = clips_in_range(ivs,i1)
print("ivsObjs:")
print(ivsObjs)
cst,tr = dp_alg(ivsObjs,i1)
print("Minimum Cost: " + str(cst))
print("Minimum Cost Tree:")
trstr = tr.printToString()
print(trstr)
                        
                
                    